---
title: "文本文件和二进制文件的区别"
date: 2021-10-13T17:42:39+08:00
draft: true
tags: ["C语言", "计算机基础"]
categories: ["C语言"]
---

首先说明，其实文本文件和二进制文件并没有本质的区别。因为我们的计算机只认识二进制，不管是 CPU 正在执行的指令，还是硬盘中保存的文件，归根结底都是像下面这样的 01 序列：

```code
0100100001100101011011000110110001101111
```

<!--more-->

这样的 01 序列，不要说电脑的使用者，就是程序员也不能一眼认出这是什么。

我们用一个简单的例子演示一下计算机处理文件的过程。在开始之前，我们有必要了解一些基本概念：

* bit(比特)：也被称为二进制位，是指二进制中的一位（0或1），它是表示信息的最小单位。

* Byte(字节)：通常用作计算机信息的计量单位。1Byte = 8bits

思考一个问题，通常描述 32 位二进制数据，为什么是用 8 个十六进制数呢？如：0x2A7C8D1F

1. 第一种理解：

4 个二进制位表示的数值范围是 0000 ~ 1111，既 0 ~ 15，刚好等同于一位 16 进制数的数值范围 0 ~ F(15)。所以可以类推得出：1 个字节包含 8 个 bit，8 个 bit 对应需要 2 个十六进制数来表示。依此类推，4Byte = 32bit，32 个 bit 就需要 8 位十六进制数来进行表示了。

2. 第二种理解：

因为 16=2^4(2的4次方)，所以 1 位十六进制数可以转换为 4 个二进制数，即十六进制的每个字符需要用 4 位二进制位来表示。所以反推 32 位二进制数换算为十六进制数后就变成 8 位。

还是以上面的 01 序列为例：

```code
0100100001100101011011000110110001101111
```

我们按照 8 位一组进行分组

```code
01001000 01100101 01101100 01101100 01101111
```

然后将其转化为十六进制

```code
01001000 01100101 01101100 01101100 01101111
48       65       6C       6C       6F 
```

现在我们得到了 5 个 2 位的十六进制数，然后我们搬出 ASCII 编码表，找到其对应的字符。

```code
Oct   Dec   Hex   Char                        Oct   Dec   Hex   Char
────────────────────────────────────────────────────────────────────────
000   0     00    NUL '\0'                    100   64    40    @
001   1     01    SOH (start of heading)      101   65    41    A
002   2     02    STX (start of text)         102   66    42    B
003   3     03    ETX (end of text)           103   67    43    C
004   4     04    EOT (end of transmission)   104   68    44    D
005   5     05    ENQ (enquiry)               105   69    45    E
006   6     06    ACK (acknowledge)           106   70    46    F
007   7     07    BEL '\a' (bell)             107   71    47    G
010   8     08    BS  '\b' (backspace)        110   72    48    H
011   9     09    HT  '\t' (horizontal tab)   111   73    49    I
012   10    0A    LF  '\n' (new line)         112   74    4A    J
013   11    0B    VT  '\v' (vertical tab)     113   75    4B    K
014   12    0C    FF  '\f' (form feed)        114   76    4C    L
015   13    0D    CR  '\r' (carriage ret)     115   77    4D    M
016   14    0E    SO  (shift out)             116   78    4E    N
017   15    0F    SI  (shift in)              117   79    4F    O
020   16    10    DLE (data link escape)      120   80    50    P
021   17    11    DC1 (device control 1)      121   81    51    Q
022   18    12    DC2 (device control 2)      122   82    52    R
023   19    13    DC3 (device control 3)      123   83    53    S
024   20    14    DC4 (device control 4)      124   84    54    T
025   21    15    NAK (negative ack.)         125   85    55    U
026   22    16    SYN (synchronous idle)      126   86    56    V
027   23    17    ETB (end of trans. blk)     127   87    57    W
030   24    18    CAN (cancel)                130   88    58    X
031   25    19    EM  (end of medium)         131   89    59    Y
032   26    1A    SUB (substitute)            132   90    5A    Z
033   27    1B    ESC (escape)                133   91    5B    [
034   28    1C    FS  (file separator)        134   92    5C    \  '\\'
035   29    1D    GS  (group separator)       135   93    5D    ]
036   30    1E    RS  (record separator)      136   94    5E    ^
037   31    1F    US  (unit separator)        137   95    5F    _
040   32    20    SPACE                       140   96    60    `
041   33    21    !                           141   97    61    a
042   34    22    "                           142   98    62    b
043   35    23    #                           143   99    63    c
044   36    24    $                           144   100   64    d
045   37    25    %                           145   101   65    e
046   38    26    &                           146   102   66    f
047   39    27    ′                           147   103   67    g
050   40    28    (                           150   104   68    h
051   41    29    )                           151   105   69    i
052   42    2A    *                           152   106   6A    j
053   43    2B    +                           153   107   6B    k
054   44    2C    ,                           154   108   6C    l
055   45    2D    -                           155   109   6D    m
056   46    2E    .                           156   110   6E    n
057   47    2F    /                           157   111   6F    o

060   48    30    0                           160   112   70    p
061   49    31    1                           161   113   71    q
062   50    32    2                           162   114   72    r
063   51    33    3                           163   115   73    s
064   52    34    4                           164   116   74    t
065   53    35    5                           165   117   75    u
066   54    36    6                           166   118   76    v
067   55    37    7                           167   119   77    w
070   56    38    8                           170   120   78    x
071   57    39    9                           171   121   79    y
072   58    3A    :                           172   122   7A    z
073   59    3B    ;                           173   123   7B    {
074   60    3C    <                           174   124   7C    |
075   61    3D    =                           175   125   7D    }
076   62    3E    >                           176   126   7E    ~
077   63    3F    ?                           177   127   7F    DEL
```

不难发现，我们的那一串 01 序列最终翻译出来就是：`Hello`

把上面的过程稍作简化，从 4 位二进制数直接向 ASCII 码表对应的字符翻译，就可以大致认为是计算机读取文本文件的原理，实际上，由于 ASCII 字符集能表示的字符已经远远无法满足人们的使用，现在使用的往往是诸如 Unicode 这样的大型字符集，但是基本原理和使用 ASCII 字符集别无二致，只是能表示的字符多了一些，需要的二进制位长了一些。

有些优秀的同学可能会问，那我为什么就一定要用 ASCII 码表或者 Unicode 表来查，而不是别的什么表呢？这个问题就引出了文件类型的概念。当你打开一个扩展名为 txt 的文件，或者虽然扩展名不是 txt，但是你使用文本编辑器强行打开时，文本编辑器就会认为这是一个文本文件，然后使用文本文件对应的规则来“翻译”这些二进制序列。

可想而知，如果这个文件确实是文本文件，那么解析出来就是人类可以看懂的信息，如果这个文件本来就不是一个文本文件，那么强行解析出来就会变成杂乱无章的字符组合，这样的字符组合就有一个为人们熟知的名字——乱码。

同样，对于其他类型的文件，比如音频、图片、视频，计算机会用不同的解码方式去解读他们包含的二进制序列，虽然乍一看都是 0101，但是因为“翻译”方式的不同，他们就可以表示不同类型的信息。文件之所以要加扩展名，就是为了让计算机能够知道，在读取这个文件的时候应该使用哪本“字典”来进行翻译，这样才能够呈现出它本来的信息。

其实在编程的概念里，只要是使用文本编辑器打开可以展现出人类可读(human-readable)的信息的文件，都可以算作宽泛的文本文件，如 txt，html，css，java，xml 等等，这些文件的编码都符合某种文字编码规范，如上文提到的 ASCII、Unicode 还有以前中文中经常使用的 GB2312；反之，如果文件的编码不符合任何一种文字编码规范，使用文本编辑器打开只能看到乱码，就可以认为它属于二进制文件。要想打开二进制文件，就必须要知道该文件所对应的编码规范，有些二进制文件使用通用的规范进行编码，比如常见的图片格式 JPEG，音频格式 MPEG-3，视频格式 MPEG-4，而有些二进制文件的编码格式只有程序的开发者自己清楚，这样的文件对于普通的用户来说就几乎是保密的。

注：文章转自知乎用户“机事本”的回答，本文做了一些修改。原文地址：[https://www.zhihu.com/question/19971994/answer/570107874](https://www.zhihu.com/question/19971994/answer/570107874)
